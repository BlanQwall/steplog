<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Season Plan · Berlin 2026 · StepLog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    /* Season timeline (weeks & cycles) */
    #season-timeline-container {
      margin-top: 1.5rem;
      margin-bottom: 1.25rem;
      position: relative;
    }

    #season-timeline-bar {
      display: flex;
      height: 24px;
      border-radius: 999px;
      overflow: hidden;
      background: #e0e3ea;
      border: 1px solid #111;
    }

    #season-timeline-labels {
      display: flex;
      margin-top: 0.25rem;
      font-size: 0.8rem;
      color: #333;
    }

    .season-cycle-label {
      flex: 1;
      text-align: center;
      font-weight: 500;
    }

    .season-cycle-block {
      display: flex;
      height: 100%;
    }

    .season-week-tick {
      flex: 1;
      border-left: 1px solid #111;
      opacity: 0.8;
    }

    .season-week-tick:first-child {
      border-left: none;
    }

    .season-week-current {
      background: rgba(0, 0, 0, 0.15);
    }

    #season-timeline-arrow {
      position: absolute;
      bottom: 100%;
      transform: translateX(-50%);
      display: none;
    }

    #season-timeline-arrow .arrow-head {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 10px solid #111;
    }
    :root {
      --berlin-blue: #0057aa;
      --berlin-blue-dark: #003e7a;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #f7f7f7;
      color: #222;
      max-width: 1200px;
      margin-inline: auto;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.25rem;
    }

    h2 {
      margin-top: 2rem;
      font-size: 1.3rem;
    }

    .subtitle {
      font-size: 0.95rem;
      color: #666;
      margin-bottom: 1.5rem;
    }

    .current-week-card {
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
      background: #fff;
      border-left: 4px solid var(--berlin-blue);
      box-shadow: 0 4px 10px rgba(0,0,0,0.04);
    }

    .current-week-card-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .current-week-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: var(--berlin-blue);
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .current-week-card-meta {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 0.25rem;
    }

    .current-week-link {
      font-size: 0.9rem;
      margin-top: 0.25rem;
    }

    .current-week-link a {
      color: var(--berlin-blue);
      text-decoration: none;
    }

    .current-week-link a:hover {
      text-decoration: underline;
    }

    .table-wrap {
      overflow-x: auto;
      background: #fff;
      border-radius: 0.75rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.04);
      padding: 0.75rem;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 700px;
      font-size: 0.9rem;
    }

    thead {
      background: #f0f3f8;
    }

    th, td {
      padding: 0.5rem 0.75rem;
      text-align: left;
      border-bottom: 1px solid #eee;
      vertical-align: middle;
    }

    th {
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #555;
    }

    tr:last-child td {
      border-bottom: none;
    }

    .week-label {
      font-weight: 600;
    }

    .cycle-tag {
      font-size: 0.8rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: #eef1ff;
      color: #2b4b99;
      white-space: nowrap;
    }

    .cycle-1 { background: #eef7ff; color: #21527a; }
    .cycle-2 { background: #e6fbf0; color: #1d6b3a; }
    .cycle-3 { background: #fff6e5; color: #925d12; }
    .cycle-4 { background: #f9e6ff; color: #6a2c8f; }
    .cycle-5 { background: #e9f5ff; color: #004f7c; }
    .cycle-final { background: #ffe9eb; color: #a02332; }

    .current-row {
      background: #e8f1ff;
      position: relative;
    }

    .current-row::before {
      content: "THIS WEEK";
      position: absolute;
      left: 0;
      top: 0;
      transform: translate(-100%, 0);
      font-size: 0.7rem;
      padding: 0.2rem 0.4rem;
      border-radius: 0.25rem;
      background: var(--berlin-blue);
      color: #fff;
      white-space: nowrap;
    }

    .small-note {
      font-size: 0.8rem;
      color: #777;
      margin-top: 0.5rem;
    }

    a.week-link {
      color: var(--berlin-blue);
      text-decoration: none;
      font-size: 0.85rem;
    }

    a.week-link:hover {
      text-decoration: underline;
    }

    header nav {
      margin-bottom: 1rem;
      font-size: 0.9rem;
    }

    header nav a {
      color: var(--berlin-blue);
      text-decoration: none;
      margin-right: 1rem;
    }

    header nav a:hover {
      text-decoration: underline;
    }

    /* Cycles overview + nested weeks */
    #cycles-table tbody tr.cycle-row {
      cursor: pointer;
      transition: background 0.15s ease;
    }

    #cycles-table tbody tr.cycle-row:hover {
      background: #f5f7ff;
    }

    #cycles-table tbody tr.cycle-row.current-cycle-row {
      background: #e8f1ff;
    }

    .cycle-link {
      color: var(--berlin-blue);
      text-decoration: none;
      font-weight: 600;
    }

    .cycle-link:hover {
      text-decoration: underline;
    }
    .cycle-name-disabled {
      color: #222;
      font-weight: 600;
    }

    .cycle-weeks-row td {
      background: #fafbff;
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
    }

    .cycle-weeks-wrapper h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 0.95rem;
    }

    .nested-weeks-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    .nested-weeks-table th,
    .nested-weeks-table td {
      border-bottom: 1px solid #ddd;
      padding: 0.35rem 0.5rem;
      text-align: left;
    }

    .nested-weeks-table th {
      background: #edf1ff;
      font-weight: 600;
    }

    .nested-weeks-table tr:last-child td {
      border-bottom: none;
    }

    .disabled-link {
      color: #999;
      text-decoration: none;
      cursor: default;
    }

    .current-week-row {
      background: #e0ecff;
      font-weight: 600;
    }

    .header-main {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
    }

    .header-text {
      flex: 1 1 auto;
    }

    .berlin-logo {
      max-width: 240px;
      height: auto;
    }

    .berlin-brand {
      color: var(--berlin-blue);
    }

    .season-chart-container {
      margin-top: 1.5rem;
      margin-bottom: 2rem;
      width: 80%;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }

    #season-weeks-chart {
      width: 100%;
      height: 320px;
      border: 1px solid #eee;
      background: #fff;
      display: block;
    }

    .chart-legend {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      text-align: center;
    }

    .chart-legend-item {
      display: inline-flex;
      align-items: center;
      margin-right: 1.5rem;
    }

    .legend-color {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 0.35rem;
      border-radius: 3px;
    }

    .legend-distance { background: #1f77b4; }
    .legend-effort { background: #d62728; }
    .legend-sessions { background: #2ca02c; }

    /* ----- Site footer ----- */
    .site-footer {
      margin-top: 2.5rem;
      padding-top: 1.25rem;
      padding-bottom: 1.5rem;
      border-top: 1px solid #ddd;
      color: #777;
      font-size: 0.85rem;
      background: transparent;
    }

    .site-footer .footer-inner {
      max-width: 960px;
      margin: 0 auto;
      padding: 0 0.5rem;
      text-align: center;
    }

    .site-footer p {
      margin: 0.15rem 0;
    }

    .site-footer .footer-sub {
      font-size: 0.8rem;
    }

    .site-footer a {
      color: var(--berlin-blue);
      text-decoration: none;
    }

    .site-footer a:hover {
      color: var(--berlin-blue-dark);
      text-decoration: underline;
    }
    @media (max-width: 720px) {
      .header-main {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .header-text {
        max-width: 100%;
      }

      .berlin-logo {
        max-width: 70%;
        height: auto;
        margin-top: 0.5rem;
        align-self: flex-start;
      }
    }
  </style>
</head>

<body>
  <header>
    <nav>
      <a href="../index.html">← Back to StepLog Home</a>
    </nav>
    <div class="header-main">
      <div class="header-text">
        <h1>Season Plan · <span class="berlin-brand">Berlin 2026</span></h1>
        <p class="subtitle">
          Berlin 2026 is a full-year training season that I designed to prepare for the
          <a href="https://www.bmw-berlin-marathon.com/en/" target="_blank" rel="noopener">BMW Berlin-Marathon 2026</a>,
          held on 2026-09-27. The season runs from 2025-09-25 all the way to race day on 2026-09-27, with one clear objective:
          to finish the Berlin Marathon in under 3 hours (Sub-3). My current marathon personal best is 3:23 from the Paris Marathon 2025,
          so improving from 3:23 down to Sub-3 in my forties is a significant challenge. To make this realistic, I have divided the year
          into several progressive training cycles, each built around an intermediate goal race, gradually developing speed, endurance
          and race execution towards the final Sub-3 attempt.
        </p>
        <p class="subtitle">
          This page summarises the overall structure of the Berlin 2026 season. It presents all cycles and weeks on a single timeline
          and lets me jump to the detailed week logs and individual cycle pages when needed. The purpose is simple: to keep a clear record
          of how the year is organised, so that past training can be reviewed, current training has context, and future training follows
          a coherent path towards Berlin 2026.
        </p>
      </div>
      <img src="./assets/Berlin_2026_logo_200px.png" alt="Berlin 2026 logo" class="berlin-logo" />
    </div>
  </header>

  <section id="current-week-section" class="current-week-card" style="display:none;">
    <div class="current-week-card-title">
      <span>Current Week</span>
      <span class="current-week-badge">Now</span>
    </div>
    <div id="current-week-meta" class="current-week-card-meta"></div>
    <div id="current-week-dates" class="current-week-card-meta"></div>
    <div id="current-week-focus" class="current-week-card-meta"></div>
    <div id="current-week-link" class="current-week-link"></div>
  </section>

  <section>
    <h2>Cycles · Training overview</h2>
    <div id="season-timeline-container">
      <div id="season-timeline-arrow">
        <div class="arrow-head"></div>
      </div>
      <div id="season-timeline-bar"></div>
      <div id="season-timeline-labels"></div>
    </div>
    <p class="small-note">
      The progress bar above uses weeks as ticks and colours to indicate cycles. The arrow marks the week I am currently in.
    </p>
    <div class="table-wrap">
      <table id="cycles-table">
        <thead>
          <tr>
            <th>Cycle</th>
            <th>Date range</th>
            <th>Length (weeks)</th>
            <th>Final event</th>
            <th>Target</th>
          </tr>
        </thead>
        <tbody>
          <!-- JS will inject cycle rows here -->
        </tbody>
      </table>
    </div>
    <p class="small-note">
      Click on a row to expand the weeks inside that cycle and see their date range, distance, number of sessions and average effort.
      The cycle that contains the current date is highlighted, and when expanded, the current week is also highlighted in the nested table.
    </p>
  </section>


  <div class="season-chart-container">
    <canvas id="season-weeks-chart" width="960" height="320"></canvas>
    <div class="chart-legend">
      <span class="chart-legend-item">
        <span class="legend-color legend-distance"></span>
        Distance (km)
      </span>
      <span class="chart-legend-item">
        <span class="legend-color legend-effort"></span>
        Avg effort
      </span>
      <span class="chart-legend-item">
        <span class="legend-color legend-sessions"></span>
        Sessions
      </span>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-inner">
      <p>StepLog · Record every step toward the next goal</p>
      <p class="footer-sub">A <a href="https://github.com/BlanQwall/StepLog">GitHub Repertory</a> of © <a href="https://github.com/BlanQwall/">BAI Qiang</a> </p>
    </div>
  </footer>

  <script>
    // 解析 YYYY-MM-DD 为本地日期（避免浏览器差异）
    function parseLocalDate(dateStr) {
      const [y, m, d] = dateStr.split("-").map(Number);
      return new Date(y, m - 1, d); // month: 0-based
    }

    // 格式化日期为 YYYY-MM-DD
    function formatDate(dateObj) {
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2, "0");
      const d = String(dateObj.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    // Cycle 日期范围格式化
    function formatDateRange(startStr, endStr) {
      return `${startStr} → ${endStr}`;
    }

    function isTodayInRange(today, startStr, endStr) {
      const start = parseLocalDate(startStr);
      const end = parseLocalDate(endStr);
      return today >= start && today <= end;
    }

    // 数据模型：Cycles + 每个 cycle 内的周
    // ⚠️ 日期、长度、周数据目前是示例，你可以根据实际计划调整和补全。
    const cyclesData = [
      {
        id: 1,
        name: "Cycle 1 · Alès 10K",
        startDate: "2025-09-29",
        endDate: "2025-11-09",
        lengthWeeks: 6,
        finalEvent: "Foulées d'Agglo Alès 10K",
        target: "10K @ 4:00/km",
        cyclePage: "./cycles/cycle-1.html",
        weeks: [
          {
            order: 1,
            startDate: "2025-09-29",
            endDate: "2025-10-05",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin.html?week=2025-09-29"
          },
          {
            order: 2,
            startDate: "2025-10-06",
            endDate: "2025-10-12",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin.html?week=2025-10-06"
          },
          {
            order: 3,
            startDate: "2025-10-13",
            endDate: "2025-10-19",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin.html?week=2025-10-13"
          },
          {
            order: 4,
            startDate: "2025-10-20",
            endDate: "2025-10-26",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin.html?week=2025-10-20"
          },
          {
            order: 5,
            startDate: "2025-10-27",
            endDate: "2025-11-02",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin.html?week=2025-10-27"
          },
          {
            order: 6,
            startDate: "2025-11-03",
            endDate: "2025-11-09",
            distanceKm: "",
            sessions: "",
            avgEffort: "Race week · Alès 10K",
            weekUrl: "../weeklog/week-berlin.html?week=2025-11-03"
          }
        ]
      },
      {
        id: 2,
        name: "Cycle 2 · Barcelona HM",
        startDate: "2025-11-10",
        endDate: "2026-02-15",
        lengthWeeks: 14,
        finalEvent: "Barcelona Half Marathon",
        target: "HM @ 4:16/km",
        cyclePage: "./cycles/cycle-2.html",
        weeks: [
          {
            order: 1,
            startDate: "2025-11-10",
            endDate: "2025-11-16",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin.html?week=2025-11-10"
          },
          {
            order: 2,
            startDate: "2025-11-17",
            endDate: "2025-11-23",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin.html?week=2025-11-17"
          }
          // 之后可以在这里继续补充后续周：order 3, 4, ..., 直到 Barcelona 半马比赛周
        ]
      },
      {
        id: 3,
        name: "Cycle 3 · Montauban Marathon",
        startDate: "2026-02-23",
        endDate: "2026-03-29",
        lengthWeeks: 5,
        finalEvent: "Marathon de Montauban",
        target: "&lt; 3:08 for FRA Champs qualification",
        cyclePage: "./cycles/cycle-3.html",
        weeks: [
          // 之后可以在这里补充 Cycle 3 的周计划
        ]
      },
      {
        id: 4,
        name: "Cycle 4 · France Championship",
        startDate: "2026-04-06",
        endDate: "2026-05-03",
        lengthWeeks: 4,
        finalEvent: "Championnats de France de Marathon (Ambès)",
        target: "Race & gain experience",
        cyclePage: "./cycles/cycle-4.html",
        weeks: [
          // 之后可以在这里补充 Cycle 4 的周计划
        ]
      },
      {
        id: 5,
        name: "Cycle 5 · Summer Block",
        startDate: "2026-05-04",
        endDate: "2026-08-30",
        lengthWeeks: 17,
        finalEvent: "Berlin Marathon prep",
        target: "Build Sub-3 engine",
        cyclePage: "./cycles/cycle-5.html",
        weeks: [
          // 之后可以在这里补充夏训的周计划（如果需要覆盖默认生成）
        ]
      },
      {
        id: 6,
        name: "Final Cycle · Berlin Marathon 2026",
        startDate: "2026-08-31",
        endDate: "2026-09-21",
        lengthWeeks: 4,
        finalEvent: "Berlin Marathon 2026",
        target: "Sub-3 hours",
        cyclePage: "./cycles/final.html",
        weeks: [
          // Berlin Marathon final sharpening & race week
        ]
      }
    ];

    function buildCycleWeeks(cycle) {
      const overrides = cycle.weeks || [];
      const overrideByStart = {};
      overrides.forEach(w => {
        if (w.startDate) {
          overrideByStart[w.startDate] = w;
        }
      });

      const fullWeeks = [];
      let current = parseLocalDate(cycle.startDate);
      const end = parseLocalDate(cycle.endDate);
      let order = 1;

      while (current <= end) {
        const startStr = formatDate(current);
        const weekEnd = new Date(current);
        weekEnd.setDate(weekEnd.getDate() + 6);
        const endStr = formatDate(weekEnd);

        const baseWeek = {
          order,
          startDate: startStr,
          endDate: endStr,
          distanceKm: "",
          sessions: "",
          avgEffort: "",
          weekUrl: `../weeklog/week-berlin.html?week=${startStr}`
        };

        const overrideWeek = overrideByStart[startStr] || {};
        fullWeeks.push(Object.assign({}, baseWeek, overrideWeek));

        current.setDate(current.getDate() + 7);
        order += 1;
      }

      return fullWeeks;
    }

    const today = new Date();

    function getCurrentCycleIndex() {
      // 优先找 today 在范围内的 cycle
      for (let i = 0; i < cyclesData.length; i++) {
        if (isTodayInRange(today, cyclesData[i].startDate, cyclesData[i].endDate)) {
          return i;
        }
      }
      // 如果找不到，使用最接近的（在最早之前 → 第一个；在最晚之后 → 最后一个）
      const first = cyclesData[0];
      const last = cyclesData[cyclesData.length - 1];
      const firstStart = parseLocalDate(first.startDate);
      const lastEnd = parseLocalDate(last.endDate);
      if (today < firstStart) return 0;
      if (today > lastEnd) return cyclesData.length - 1;
      // 中间空档，找 startDate 离 today 最近的
      let closestIndex = 0;
      let minDiff = Infinity;
      cyclesData.forEach((c, idx) => {
        const start = parseLocalDate(c.startDate);
        const diff = Math.abs(today - start);
        if (diff < minDiff) {
          minDiff = diff;
          closestIndex = idx;
        }
      });
      return closestIndex;
    }

    function getCurrentWeekOrderInCycle(cycle) {
      const weeks = buildCycleWeeks(cycle);
      for (const w of weeks) {
        if (isTodayInRange(today, w.startDate, w.endDate)) {
          return w.order;
        }
      }
      return null;
    }

    function createWeeksTable(cycle, currentWeekOrder) {
      const weeks = buildCycleWeeks(cycle);
      if (!weeks.length) {
        return `<p class="small-note">No week details yet for this cycle.</p>`;
      }

      const rows = weeks.map(week => {
        const dr = formatDateRange(week.startDate, week.endDate);
        const isCurrent = currentWeekOrder != null && week.order === currentWeekOrder;
        const trClass = isCurrent ? ' class="current-week-row"' : "";
        const distance = (week.distanceKm !== "" && week.distanceKm != null)
          ? `${week.distanceKm} km`
          : "";
        const sessions = week.sessions || "";
        const avgEffort = week.avgEffort || "";

        const startObj = parseLocalDate(week.startDate);
        const isPastOrCurrent = today >= startObj;

        let dateCell;
        if (week.weekUrl && isPastOrCurrent) {
          dateCell = `<a href="${week.weekUrl}">${dr}</a>`;
        } else if (week.weekUrl) {
          dateCell = `<span class="disabled-link">${dr}</span>`;
        } else {
          dateCell = dr;
        }

        return `
          <tr${trClass} data-week-start="${week.startDate}" data-cycle-id="${cycle.id}">
            <td>${week.order}</td>
            <td>${dateCell}</td>
            <td>${distance}</td>
            <td>${sessions}</td>
            <td>${avgEffort}</td>
          </tr>
        `;
      }).join("");

      return `
        <table class="nested-weeks-table">
          <thead>
            <tr>
              <th>Week #</th>
              <th>Date range</th>
              <th>Distance</th>
              <th>Sessions</th>
              <th>Avg effort</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
      `;
    }

    function populateWeeksTable(detailRow, cycle) {
      const weeks = buildCycleWeeks(cycle);
      const tbody = detailRow.querySelector(".nested-weeks-table tbody");
      if (!tbody) return;

      weeks.forEach(week => {
        const row = tbody.querySelector(`tr[data-week-start="${week.startDate}"]`);
        if (!row) return;

        const cells = row.querySelectorAll("td");
        if (cells.length < 5) return;

        const distanceCell = cells[2];
        const sessionsCell = cells[3];
        const effortCell = cells[4];

        const jsonPath = `../data/week-${week.startDate}.json`;

        fetch(jsonPath)
          .then(resp => {
            if (!resp.ok) {
              throw new Error("No data");
            }
            return resp.json();
          })
          .then(data => {
            if (typeof data.total_distance_km === "number") {
              distanceCell.textContent = data.total_distance_km.toFixed(2) + " km";
            }
            if (typeof data.activity_count === "number") {
              sessionsCell.textContent = data.activity_count;
            }
            if (typeof data.avg_suffer_score === "number") {
              effortCell.textContent = data.avg_suffer_score.toFixed(1);
            }
          })
          .catch(() => {
            // No JSON for this week: leave cells empty
          });
      });
    }

    function renderCyclesTable(currentCycleIndex, currentWeekOrderByCycleId) {
      const tbody = document.querySelector("#cycles-table tbody");
      tbody.innerHTML = "";

      cyclesData.forEach((cycle, idx) => {
        const tr = document.createElement("tr");
        tr.classList.add("cycle-row");
        if (idx === currentCycleIndex) {
          tr.classList.add("current-cycle-row");
        }
        tr.dataset.cycleId = cycle.id;

        const isFutureCycle = idx > currentCycleIndex;
        const nameCellHtml = (!isFutureCycle && cycle.cyclePage)
          ? `<a href="${cycle.cyclePage}" class="cycle-link">${cycle.name}</a>`
          : `<span class="cycle-name-disabled">${cycle.name}</span>`;

        tr.innerHTML = `
          <td>
            ${nameCellHtml}
          </td>
          <td>${formatDateRange(cycle.startDate, cycle.endDate)}</td>
          <td>${cycle.lengthWeeks}</td>
          <td>${cycle.finalEvent}</td>
          <td>${cycle.target}</td>
        `;

        tbody.appendChild(tr);
      });

      // 展开/折叠逻辑 + 在展开的二级表格中高亮当前周
      tbody.addEventListener("click", (event) => {
        const row = event.target.closest("tr.cycle-row");
        if (!row) return;

        const cycleId = row.dataset.cycleId;
        const existingDetailRow = row.nextElementSibling;
        const isOpen = existingDetailRow && existingDetailRow.classList.contains("cycle-weeks-row");

        // 如果已经展开则折叠
        if (isOpen) {
          existingDetailRow.remove();
          row.classList.remove("expanded");
          return;
        }

        // 关闭其他已展开的行
        const allDetailRows = tbody.querySelectorAll(".cycle-weeks-row");
        allDetailRows.forEach(r => r.previousElementSibling?.classList.remove("expanded"));
        allDetailRows.forEach(r => r.remove());

        const cycle = cyclesData.find(c => String(c.id) === String(cycleId));
        const detailRow = document.createElement("tr");
        detailRow.classList.add("cycle-weeks-row");

        const currentWeekOrder = currentWeekOrderByCycleId[cycle.id] ?? null;

        detailRow.innerHTML = `
          <td colspan="5">
            <div class="cycle-weeks-wrapper">
              <h3>Weeks in ${cycle.name}</h3>
              ${createWeeksTable(cycle, currentWeekOrder)}
            </div>
          </td>
        `;

        row.insertAdjacentElement("afterend", detailRow);
        row.classList.add("expanded");

        // After the nested table is rendered, populate distance/sessions/effort
        populateWeeksTable(detailRow, cycle);
      });
    }

    function updateCurrentWeekCard(currentCycleIndex, currentWeekOrderByCycleId) {
      const card = document.getElementById("current-week-section");
      const meta = document.getElementById("current-week-meta");
      const dates = document.getElementById("current-week-dates");
      const focus = document.getElementById("current-week-focus");
      const link = document.getElementById("current-week-link");

      if (currentCycleIndex < 0 || currentCycleIndex >= cyclesData.length) {
        card.style.display = "none";
        return;
      }

      const cycle = cyclesData[currentCycleIndex];
      const cycleRangeLabel = formatDateRange(cycle.startDate, cycle.endDate);
      const currentWeekOrder = currentWeekOrderByCycleId[cycle.id] ?? null;
      const weeks = buildCycleWeeks(cycle);
      let currentWeek = null;

      if (currentWeekOrder != null) {
        currentWeek = weeks.find(w => w.order === currentWeekOrder) || null;
      }

      if (currentWeek) {
        const weekRange = formatDateRange(currentWeek.startDate, currentWeek.endDate);
        meta.textContent = `${cycle.name} · Week ${currentWeek.order}`;
        dates.textContent = `Date: ${weekRange}`;
        focus.textContent = cycle.target ? `Target: ${cycle.target}` : "";

        if (currentWeek.weekUrl) {
          link.innerHTML = `Week log: <a href="${currentWeek.weekUrl}">${currentWeek.weekUrl}</a>`;
        } else {
          link.innerHTML = "";
        }
      } else {
        meta.textContent = cycle.name;
        dates.textContent = `Cycle range: ${cycleRangeLabel}`;
        focus.textContent = cycle.target ? `Target: ${cycle.target}` : "";

        // fallback: compute current week URL from today's Monday
        const todayLocal = new Date();
        const day = todayLocal.getDay(); // 0=Sun, 1=Mon
        const diffToMonday = (day === 0 ? -6 : 1) - day;
        const monday = new Date(todayLocal);
        monday.setDate(todayLocal.getDate() + diffToMonday);

        const y = monday.getFullYear();
        const m = String(monday.getMonth() + 1).padStart(2, "0");
        const d = String(monday.getDate()).padStart(2, "0");
        const weekStr = `${y}-${m}-${d}`;

        link.innerHTML = `Week page: <a href="../weeklog/week-berlin.html?week=${weekStr}">week-${weekStr}</a>`;
      }

      card.style.display = "block";
    }

    function renderSeasonTimeline(currentCycleIndex, currentWeekOrderByCycleId) {
      const bar = document.getElementById("season-timeline-bar");
      const arrow = document.getElementById("season-timeline-arrow");
      const labels = document.getElementById("season-timeline-labels");
      if (!bar || !arrow) return;

      bar.innerHTML = "";
      if (labels) {
        labels.innerHTML = "";
      }

      // Collect cycles with their weeks
      const cycleBlocks = [];
      let totalWeeks = 0;
      cyclesData.forEach((cycle, idx) => {
        const weeks = buildCycleWeeks(cycle);
        cycleBlocks.push({ cycle, idx, weeks });
        totalWeeks += weeks.length;
      });

      // Build visual blocks
      cycleBlocks.forEach(({ cycle, idx, weeks }) => {
        const cycleDiv = document.createElement("div");
        cycleDiv.className = "season-cycle-block";
        cycleDiv.style.flex = String(weeks.length);

        // Alternate background colors per cycle
        const isEven = idx % 2 === 0;
        cycleDiv.style.background = isEven ? "var(--berlin-blue-light, #e5f0ff)" : "var(--berlin-blue, #0057aa)";

        weeks.forEach((week) => {
          const tick = document.createElement("div");
          tick.className = "season-week-tick";

          const currentWeekOrder = currentWeekOrderByCycleId[cycle.id];
          if (currentWeekOrder != null && week.order === currentWeekOrder && idx === currentCycleIndex) {
            tick.classList.add("season-week-current");
          }

          cycleDiv.appendChild(tick);
        });

        bar.appendChild(cycleDiv);

        if (labels) {
          const labelDiv = document.createElement("div");
          labelDiv.className = "season-cycle-label";
          labelDiv.style.flex = String(weeks.length);
          let labelText;
          if (idx === cyclesData.length - 1) {
            labelText = "Final";
          } else {
            labelText = "Cycle " + (idx + 1);
          }
          labelDiv.textContent = labelText;
          labels.appendChild(labelDiv);
        }
      });

      // Compute arrow position (current week index among all weeks)
      let currentIndex = null;
      let running = 0;
      cycleBlocks.forEach(({ cycle, weeks }) => {
        const currentWeekOrder = currentWeekOrderByCycleId[cycle.id];
        if (currentWeekOrder != null && currentIndex === null && cyclesData[currentCycleIndex].id === cycle.id) {
          currentIndex = running + (currentWeekOrder - 1);
        }
        running += weeks.length;
      });

      if (currentIndex == null || totalWeeks === 0) {
        arrow.style.display = "none";
      } else {
        const positionPercent = ((currentIndex + 0.5) / totalWeeks) * 100;
        arrow.style.left = positionPercent + "%";
        arrow.style.display = "block";
      }
    }

    (function init() {
      const currentCycleIndex = getCurrentCycleIndex();
      const currentWeekOrderByCycleId = {};

      cyclesData.forEach(cycle => {
        currentWeekOrderByCycleId[cycle.id] = getCurrentWeekOrderInCycle(cycle);
      });

      renderCyclesTable(currentCycleIndex, currentWeekOrderByCycleId);
      updateCurrentWeekCard(currentCycleIndex, currentWeekOrderByCycleId);
      renderSeasonTimeline(currentCycleIndex, currentWeekOrderByCycleId);
    })();

    function buildSeasonChart() {
  const canvas = document.getElementById("season-weeks-chart");
  if (!canvas) return;

  const allWeeks = [];
  const cycleBoundaries = [];
  let runningIndex = 0;

  cyclesData.forEach(cycle => {
    const weeks = buildCycleWeeks(cycle);
    weeks.forEach(w => {
      allWeeks.push({ ...w, cycleId: cycle.id });
    });
    runningIndex += weeks.length;
    cycleBoundaries.push(runningIndex);
  });

  const n = allWeeks.length;
  if (n === 0) return;

  // 关键：预先按长度建好数组，用下标写入
  const labels = new Array(n);
  const distances = new Array(n).fill(null);
  const sessions = new Array(n).fill(null);
  const efforts = new Array(n).fill(null);

  let remaining = n;

  allWeeks.forEach((w, idx) => {
    labels[idx] = String(w.order ?? "");  // label 也固定放在 idx 位置

    const jsonPath = `../data/week-${w.startDate}.zh.json`;

    fetch(jsonPath)
      .then(resp => (resp.ok ? resp.json() : null))
      .then(data => {
        if (data) {
          if (typeof data.total_distance_km === "number") {
            distances[idx] = data.total_distance_km;
          }
          if (typeof data.activity_count === "number") {
            sessions[idx] = data.activity_count;
          }
          if (typeof data.avg_suffer_score === "number") {
            efforts[idx] = data.avg_suffer_score;
          }
        }
      })
      .catch(() => {
        // 出错就保持 null，不再 push
      })
      .finally(() => {
        remaining--;
        if (remaining === 0) {
          drawSeasonChart(canvas, labels, distances, sessions, efforts, cycleBoundaries);
        }
      });
  });
}

function drawSeasonChart(canvas, labels, distances, sessions, efforts, cycleBoundaries) {
  const ctx = canvas.getContext("2d");
  const width = canvas.width;
  const height = canvas.height;

  ctx.clearRect(0, 0, width, height);

  const paddingLeft = 40;
  const paddingRight = 20;
  const paddingTop = 20;
  const paddingBottom = 40;

  const chartWidth = width - paddingLeft - paddingRight;
  const chartHeight = height - paddingTop - paddingBottom;

  const values = [...distances, ...sessions, ...efforts].filter(v => typeof v === "number");
  const globalMax = values.length ? Math.max(...values) * 1.1 : 1;

  function valueToY(v) {
    if (v === null || Number.isNaN(v)) return null;
    const ratio = v / globalMax;
    return paddingTop + (1 - ratio) * chartHeight;
  }

  const stepX = labels.length > 1 ? chartWidth / (labels.length - 1) : 0;

  // axes
  ctx.strokeStyle = "#ccc";
  ctx.beginPath();
  ctx.moveTo(paddingLeft, paddingTop);
  ctx.lineTo(paddingLeft, paddingTop + chartHeight);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(paddingLeft, paddingTop + chartHeight);
  ctx.lineTo(paddingLeft + chartWidth, paddingTop + chartHeight);
  ctx.stroke();

  // vertical dashed lines to separate cycles
  if (Array.isArray(cycleBoundaries) && cycleBoundaries.length > 1 && stepX > 0) {
    ctx.save();
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = "#0057aa";
    ctx.lineWidth = 1;
    for (let i = 0; i < cycleBoundaries.length - 1; i++) {
      const idxBoundary = cycleBoundaries[i];
      if (idxBoundary <= 0 || idxBoundary >= labels.length) continue;
      const x = paddingLeft + stepX * idxBoundary - stepX / 2;
      ctx.beginPath();
      ctx.moveTo(x, paddingTop);
      ctx.lineTo(x, paddingTop + chartHeight);
      ctx.stroke();
    }
    ctx.restore();
  }

  // y-grid
  ctx.fillStyle = "#666";
  ctx.font = "11px system-ui";
  for (let i = 0; i <= 4; i++) {
    const ratio = i / 4;
    const y = paddingTop + (1 - ratio) * chartHeight;
    const val = (globalMax * ratio).toFixed(0);

    ctx.fillText(val, 4, y + 3);

    ctx.strokeStyle = i === 0 ? "#ccc" : "#eee";
    ctx.beginPath();
    ctx.moveTo(paddingLeft, y);
    ctx.lineTo(paddingLeft + chartWidth, y);
    ctx.stroke();
  }

  // x-axis ticks and labels: week # within cycle (1, 2, 3, ...)  
  ctx.fillStyle = "#333";
  labels.forEach((lab, idx) => {
    const x = paddingLeft + stepX * idx;
    const yBase = paddingTop + chartHeight;

    // small tick
    ctx.strokeStyle = "#aaa";
    ctx.beginPath();
    ctx.moveTo(x, yBase);
    ctx.lineTo(x, yBase + 4);
    ctx.stroke();

    // label (e.g. W1, W2...)
    ctx.fillText(lab, x - 10, yBase + 18);
  });

    // cycle labels centered under the x-axis (C1..C5, Final)
  if (Array.isArray(cycleBoundaries) && cycleBoundaries.length > 0 && stepX > 0) {
    ctx.fillStyle = "#555";
    ctx.font = "11px system-ui";
    const yCycleLabel = paddingTop + chartHeight + 32;

    for (let i = 0; i < cycleBoundaries.length; i++) {
      const startIndex = i === 0 ? 0 : cycleBoundaries[i - 1];
      const endExclusive = cycleBoundaries[i];
      if (endExclusive <= startIndex) continue;

      // 当前 cycle 在线上的中心索引
      const centerIndex = (startIndex + endExclusive - 1) / 2;
      const x = paddingLeft + stepX * centerIndex;

      let labelText;
      if (i === cycleBoundaries.length - 1) {
        labelText = "Final";
      } else {
        labelText = "C" + (i + 1);
      }

      ctx.fillText(labelText, x - 12, yCycleLabel);
    }
  }

  function drawLine(values, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;

    values.forEach((v, idx) => {
      const y = valueToY(v);
      if (y === null) return;

      const x = paddingLeft + stepX * idx;
      if (!started) {
        ctx.moveTo(x, y);
        started = true;
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();
  }

  drawLine(distances, "#1f77b4");
  drawLine(efforts, "#d62728");
  drawLine(sessions, "#2ca02c");
}

document.addEventListener("DOMContentLoaded", buildSeasonChart);
  </script>
</body>
</html>