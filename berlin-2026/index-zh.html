<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>赛季计划 · 柏林2026 · StepLog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    /* Season timeline (weeks & cycles) */
    #season-timeline-container {
      margin-top: 1.5rem;
      margin-bottom: 1.25rem;
      position: relative;
    }

    #season-timeline-bar {
      display: flex;
      height: 24px;
      border-radius: 999px;
      overflow: hidden;
      background: #e0e3ea;
      border: 1px solid #111;
    }

    #season-timeline-labels {
      display: flex;
      margin-top: 0.25rem;
      font-size: 0.8rem;
      color: #333;
    }

    .season-cycle-label {
      flex: 1;
      text-align: center;
      font-weight: 500;
    }

    .season-cycle-block {
      display: flex;
      height: 100%;
    }

    .season-week-tick {
      flex: 1;
      border-left: 1px solid #111;
      opacity: 0.8;
    }

    .season-week-tick:first-child {
      border-left: none;
    }

    .season-week-current {
      background: rgba(0, 0, 0, 0.15);
    }

    #season-timeline-arrow {
      position: absolute;
      bottom: 100%;
      transform: translateX(-50%);
      display: none;
    }

    #season-timeline-arrow .arrow-head {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 10px solid #111;
    }
    :root {
      --berlin-blue: #0057aa;
      --berlin-blue-dark: #003e7a;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #f7f7f7;
      color: #222;
      max-width: 1200px;
      margin-inline: auto;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.25rem;
    }

    h2 {
      margin-top: 2rem;
      font-size: 1.3rem;
    }

    .subtitle {
      font-size: 0.95rem;
      color: #666;
      margin-bottom: 1.5rem;
    }

    .current-week-card {
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
      background: #fff;
      border-left: 4px solid var(--berlin-blue);
      box-shadow: 0 4px 10px rgba(0,0,0,0.04);
    }

    .current-week-card-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .current-week-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.9rem;
      background: var(--berlin-blue);
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .current-week-card-meta {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 0.25rem;
    }

    .current-week-link {
      font-size: 0.9rem;
      margin-top: 0.25rem;
    }

    .current-week-link a {
      color: var(--berlin-blue);
      text-decoration: none;
    }

    .current-week-link a:hover {
      text-decoration: underline;
    }

    .table-wrap {
      overflow-x: auto;
      background: #fff;
      border-radius: 0.75rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.04);
      padding: 0.75rem;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 700px;
      font-size: 0.9rem;
    }

    thead {
      background: #f0f3f8;
    }

    th, td {
      padding: 0.5rem 0.75rem;
      text-align: left;
      border-bottom: 1px solid #eee;
      vertical-align: middle;
    }

    th {
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #555;
    }

    tr:last-child td {
      border-bottom: none;
    }

    .week-label {
      font-weight: 600;
    }

    .cycle-tag {
      font-size: 0.8rem;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: #eef1ff;
      color: #2b4b99;
      white-space: nowrap;
    }

    .cycle-1 { background: #eef7ff; color: #21527a; }
    .cycle-2 { background: #e6fbf0; color: #1d6b3a; }
    .cycle-3 { background: #fff6e5; color: #925d12; }
    .cycle-4 { background: #f9e6ff; color: #6a2c8f; }
    .cycle-5 { background: #e9f5ff; color: #004f7c; }
    .cycle-final { background: #ffe9eb; color: #a02332; }

    .current-row {
      background: #e8f1ff;
      position: relative;
    }

    .current-row::before {
      content: "本周";
      position: absolute;
      left: 0;
      top: 0;
      transform: translate(-100%, 0);
      font-size: 0.7rem;
      padding: 0.2rem 0.4rem;
      border-radius: 0.25rem;
      background: var(--berlin-blue);
      color: #fff;
      white-space: nowrap;
    }

    .small-note {
      font-size: 0.8rem;
      color: #777;
      margin-top: 0.5rem;
    }

    a.week-link {
      color: var(--berlin-blue);
      text-decoration: none;
      font-size: 0.85rem;
    }

    a.week-link:hover {
      text-decoration: underline;
    }

    header nav {
      margin-bottom: 1rem;
      font-size: 0.9rem;
    }

    header nav a {
      color: var(--berlin-blue);
      text-decoration: none;
      margin-right: 1rem;
    }

    header nav a:hover {
      text-decoration: underline;
    }

    /* Cycles overview + nested weeks */
    #cycles-table tbody tr.cycle-row {
      cursor: pointer;
      transition: background 0.15s ease;
    }

    #cycles-table tbody tr.cycle-row:hover {
      background: #f5f7ff;
    }

    #cycles-table tbody tr.cycle-row.current-cycle-row {
      background: #e8f1ff;
    }

    .cycle-link {
      color: var(--berlin-blue);
      text-decoration: none;
      font-weight: 600;
    }

    .cycle-link:hover {
      text-decoration: underline;
    }

    .cycle-weeks-row td {
      background: #fafbff;
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
    }

    .cycle-weeks-wrapper h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 0.95rem;
    }

    .nested-weeks-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    .nested-weeks-table th,
    .nested-weeks-table td {
      border-bottom: 1px solid #ddd;
      padding: 0.35rem 0.5rem;
      text-align: left;
    }

    .nested-weeks-table th {
      background: #edf1ff;
      font-weight: 600;
    }

    .nested-weeks-table tr:last-child td {
      border-bottom: none;
    }

    .disabled-link {
      color: #999;
      text-decoration: none;
      cursor: default;
    }

    .current-week-row {
      background: #e0ecff;
      font-weight: 600;
    }

    .header-main {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
    }

    .header-text {
      flex: 1 1 auto;
    }

    .berlin-logo {
      max-width: 240px;
      height: auto;
    }

    .berlin-brand {
      color: var(--berlin-blue);
    }

    .season-chart-container {
      margin-top: 1.5rem;
      margin-bottom: 2rem;
      width: 80%;
      margin-left: auto;
      margin-right: auto;
      text-align: center;
    }

    #season-weeks-chart {
      width: 100%;
      height: 320px;
      border: 1px solid #eee;
      background: #fff;
      display: block;
    }

    .chart-legend {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      text-align: center;
    }

    .chart-legend-item {
      display: inline-flex;
      align-items: center;
      margin-right: 1.5rem;
    }

    .legend-color {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 0.35rem;
      border-radius: 3px;
    }

    .legend-distance { background: #1f77b4; }
    .legend-effort { background: #d62728; }
    .legend-sessions { background: #2ca02c; }

    /* ----- Site footer ----- */
    .site-footer {
      margin-top: 2.5rem;
      padding-top: 1.25rem;
      padding-bottom: 1.5rem;
      border-top: 1px solid #ddd;
      color: #777;
      font-size: 0.85rem;
      background: transparent;
    }

    .site-footer .footer-inner {
      max-width: 960px;
      margin: 0 auto;
      padding: 0 0.5rem;
      text-align: center;
    }

    .site-footer p {
      margin: 0.15rem 0;
    }

    .site-footer .footer-sub {
      font-size: 0.8rem;
    }

    .site-footer a {
      color: var(--berlin-blue);
      text-decoration: none;
    }

    .site-footer a:hover {
      color: var(--berlin-blue-dark);
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <header>
    <nav>
      <a href="../index.html">← 返回 StepLog 首页</a>
    </nav>
    <div class="header-main">
      <div class="header-text">
        <h1>赛季计划 · <span class="berlin-brand">Berlin 2026</span></h1>
        <p class="subtitle">
          <b>”柏林2026“</b> 赛季是我为
          <a href="https://www.bmw-berlin-marathon.com/en/" target="_blank" rel="noopener">2026柏林马拉松</a>
          做准备的一整年训练计划。这个赛季从 2025-09-25 开始，一直持续到 2026-09-27 柏林马拉松比赛当天，目标非常明确：
          在 2026 年 9 月 27 日的柏林马拉松中，以 Sub-3（3 小时内完赛）为终点。目前我的马拉松个人最好成绩是 2025 年巴黎马拉松的 3 小时 23 分，
          对于已经年过不惑的我来说，要把成绩从 3:23 压到 3 小时以内，是一次不小的挑战。为了让这个目标更现实，我把这一年拆分成多个循序递进的训练周期（cycles），
          每个 cycle 围绕一场阶段性目标赛事，逐步在速度、耐力和比赛执行方面累积能力，最终指向柏林 Sub-3。
        </p>
        <p class="subtitle">
          本页面汇总整个 Berlin 2026 赛季的训练框架：按时间顺序展示所有训练周期及其涵盖的训练周，并在需要时跳转到对应的周记和周期页面。
          它的目的很简单——为这一整年的训练建立一条清晰的轨迹：可以回顾过去的训练，记录现在的训练，为接下来的训练明确的方向。
        </p>
      </div>
      <img src="./assets/Berlin_2026_logo-zh.png" alt="柏林2026 项目标志" class="berlin-logo" />
    </div>
  </header>

  <section id="current-week-section" class="current-week-card" style="display:none;">
    <div class="current-week-card-title">
      <span class="current-week-badge">当前周入口</span>
    </div>
    <div id="current-week-meta" class="current-week-card-meta"></div>
    <div id="current-week-dates" class="current-week-card-meta"></div>
    <div id="current-week-focus" class="current-week-card-meta"></div>
    <div id="current-week-link" class="current-week-link"></div>
  </section>

  <section>
    <h2>训练周期总览</h2>
    <div id="season-timeline-container">
      <div id="season-timeline-arrow">
        <div class="arrow-head"></div>
      </div>
      <div id="season-timeline-bar"></div>
      <div id="season-timeline-labels"></div>
    </div>
    <p class="small-note">
      上方的进度条以「周」为刻度，用不同颜色区分各个训练周期，箭头标记的是当前所在的训练周。
    </p>
    <div class="table-wrap">
      <table id="cycles-table">
        <thead>
          <tr>
            <th>周期</th>
            <th>日期范围</th>
            <th>周数</th>
            <th>最终赛事</th>
            <th>目标</th>
          </tr>
        </thead>
        <tbody>
          <!-- JS will inject cycle rows here -->
        </tbody>
      </table>
    </div>
    <p class="small-note">
      点击某一行可以展开该训练周期下的所有周，查看每周的日期范围、总里程、训练次数和平均主观强度。
      当前日期所在的训练周期会被高亮显示，在展开后，该周期中的当前周也会在下方表格中高亮。
    </p>
  </section>


  <div class="season-chart-container">
    <canvas id="season-weeks-chart" width="960" height="320"></canvas>
    <div class="chart-legend">
      <span class="chart-legend-item">
        <span class="legend-color legend-distance"></span>
        距离（公里）
      </span>
      <span class="chart-legend-item">
        <span class="legend-color legend-effort"></span>
        平均主观强度
      </span>
      <span class="chart-legend-item">
        <span class="legend-color legend-sessions"></span>
        训练次数
      </span>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-inner">
      <p>StepLog · 计划在心，脚踏实地。</p>
      <p class="footer-sub">想了解我是谁？看这里 © <a href="https://github.com/BlanQwall/">BAI Qiang</a> · StepLog项目托管于 <a href="https://github.com/BlanQwall/StepLog">GitHub 仓库</a></p>
    </div>
  </footer>

  <script>
    // 解析 YYYY-MM-DD 为本地日期（避免浏览器差异）
    function parseLocalDate(dateStr) {
      const [y, m, d] = dateStr.split("-").map(Number);
      return new Date(y, m - 1, d); // month: 0-based
    }

    // 格式化日期为 YYYY-MM-DD
    function formatDate(dateObj) {
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2, "0");
      const d = String(dateObj.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    // Cycle 日期范围格式化
    function formatDateRange(startStr, endStr) {
      return `${startStr} → ${endStr}`;
    }

    function isTodayInRange(today, startStr, endStr) {
      const start = parseLocalDate(startStr);
      const end = parseLocalDate(endStr);
      return today >= start && today <= end;
    }

    // 数据模型：Cycles + 每个 cycle 内的周
    // ⚠️ 日期、长度、周数据目前是示例，你可以根据实际计划调整和补全。
    const cyclesData = [
      {
        id: 1,
        name: "训练周期 1 · 阿莱斯10公里赛",
        startDate: "2025-09-29",
        endDate: "2025-11-09",
        lengthWeeks: 6,
        finalEvent: "阿莱斯10公里赛",
        target: "10公里配速 4:00分钟/公里",
        cyclePage: "./cycles/cycle-1-zh.html",
        weeks: [
          {
            order: 1,
            startDate: "2025-09-29",
            endDate: "2025-10-05",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin-zh.html?week=2025-09-29"
          },
          {
            order: 2,
            startDate: "2025-10-06",
            endDate: "2025-10-12",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin-zh.html?week=2025-10-06"
          },
          {
            order: 3,
            startDate: "2025-10-13",
            endDate: "2025-10-19",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin-zh.html?week=2025-10-13"
          },
          {
            order: 4,
            startDate: "2025-10-20",
            endDate: "2025-10-26",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin-zh.html?week=2025-10-20"
          },
          {
            order: 5,
            startDate: "2025-10-27",
            endDate: "2025-11-02",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin-zh.html?week=2025-10-27"
          },
          {
            order: 6,
            startDate: "2025-11-03",
            endDate: "2025-11-09",
            distanceKm: "",
            sessions: "",
            avgEffort: "Race week · Alès 10K",
            weekUrl: "../weeklog/week-berlin-zh.html?week=2025-11-03"
          }
        ]
      },
      {
        id: 2,
        name: "训练周期 2 · 巴塞罗那半程马拉松",
        startDate: "2025-11-10",
        endDate: "2026-02-15",
        lengthWeeks: 14,
        finalEvent: "巴塞罗那半程马拉松",
        target: "半马配速 4:16分钟/公里",
        cyclePage: "./cycles/cycle-2-zh.html",
        weeks: [
          {
            order: 1,
            startDate: "2025-11-10",
            endDate: "2025-11-16",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin-zh.html?week=2025-11-10"
          },
          {
            order: 2,
            startDate: "2025-11-17",
            endDate: "2025-11-23",
            distanceKm: "",
            sessions: "",
            avgEffort: "",
            weekUrl: "../weeklog/week-berlin-zh.html?week=2025-11-17"
          }
          // 之后可以在这里继续补充后续周：order 3, 4, ..., 直到 Barcelona 半马比赛周
        ]
      },
      {
        id: 3,
        name: "训练周期 3 · 蒙托邦马拉松",
        startDate: "2026-02-23",
        endDate: "2026-03-29",
        lengthWeeks: 5,
        finalEvent: "蒙托邦马拉松",
        target: "&lt; 3小时08分——达标法国马拉松锦标赛",
        cyclePage: "./cycles/cycle-3-zh.html",
        weeks: [
          // 之后可以在这里补充 Cycle 3 的周计划
        ]
      },
      {
        id: 4,
        name: "训练周期 4 · 法国马拉松锦标赛",
        startDate: "2026-04-06",
        endDate: "2026-05-03",
        lengthWeeks: 4,
        finalEvent: "法国马拉松锦标赛（Ambès）",
        target: "积攒比赛经验",
        cyclePage: "./cycles/cycle-4-zh.html",
        weeks: [
          // 之后可以在这里补充 Cycle 4 的周计划
        ]
      },
      {
        id: 5,
        name: "训练周期 5 · 夏季训练周期",
        startDate: "2026-05-04",
        endDate: "2026-08-30",
        lengthWeeks: 17,
        finalEvent: "无（暑假结束）",
        target: "柏林马拉松系统性针对训练",
        cyclePage: "./cycles/cycle-5-zh.html",
        weeks: [
          // 之后可以在这里补充夏训的周计划（如果需要覆盖默认生成）
        ]
      },
      {
        id: 6,
        name: "最终周期 · 2026柏林马拉松",
        startDate: "2026-08-31",
        endDate: "2026-09-21",
        lengthWeeks: 4,
        finalEvent: "2026柏林马拉松",
        target: "总成绩<3小时",
        cyclePage: "./cycles/final-zh.html",
        weeks: [
          // Berlin Marathon final sharpening & race week
        ]
      }
    ];

    function buildCycleWeeks(cycle) {
      const overrides = cycle.weeks || [];
      const overrideByStart = {};
      overrides.forEach(w => {
        if (w.startDate) {
          overrideByStart[w.startDate] = w;
        }
      });

      const fullWeeks = [];
      let current = parseLocalDate(cycle.startDate);
      const end = parseLocalDate(cycle.endDate);
      let order = 1;

      while (current <= end) {
        const startStr = formatDate(current);
        const weekEnd = new Date(current);
        weekEnd.setDate(weekEnd.getDate() + 6);
        const endStr = formatDate(weekEnd);

        const baseWeek = {
          order,
          startDate: startStr,
          endDate: endStr,
          distanceKm: "",
          sessions: "",
          avgEffort: "",
          weekUrl: `../weeklog/week-berlin-zh.html?week=${startStr}`
        };

        const overrideWeek = overrideByStart[startStr] || {};
        fullWeeks.push(Object.assign({}, baseWeek, overrideWeek));

        current.setDate(current.getDate() + 7);
        order += 1;
      }

      return fullWeeks;
    }

    const today = new Date();

    function getCurrentCycleIndex() {
      // 优先找 today 在范围内的 cycle
      for (let i = 0; i < cyclesData.length; i++) {
        if (isTodayInRange(today, cyclesData[i].startDate, cyclesData[i].endDate)) {
          return i;
        }
      }
      // 如果找不到，使用最接近的（在最早之前 → 第一个；在最晚之后 → 最后一个）
      const first = cyclesData[0];
      const last = cyclesData[cyclesData.length - 1];
      const firstStart = parseLocalDate(first.startDate);
      const lastEnd = parseLocalDate(last.endDate);
      if (today < firstStart) return 0;
      if (today > lastEnd) return cyclesData.length - 1;
      // 中间空档，找 startDate 离 today 最近的
      let closestIndex = 0;
      let minDiff = Infinity;
      cyclesData.forEach((c, idx) => {
        const start = parseLocalDate(c.startDate);
        const diff = Math.abs(today - start);
        if (diff < minDiff) {
          minDiff = diff;
          closestIndex = idx;
        }
      });
      return closestIndex;
    }

    function getCurrentWeekOrderInCycle(cycle) {
      const weeks = buildCycleWeeks(cycle);
      for (const w of weeks) {
        if (isTodayInRange(today, w.startDate, w.endDate)) {
          return w.order;
        }
      }
      return null;
    }

    function createWeeksTable(cycle, currentWeekOrder) {
      const weeks = buildCycleWeeks(cycle);
      if (!weeks.length) {
        return `<p class="small-note">本训练周期暂时还没有填写详细的周计划。</p>`;
      }

      const rows = weeks.map(week => {
        const dr = formatDateRange(week.startDate, week.endDate);
        const isCurrent = currentWeekOrder != null && week.order === currentWeekOrder;
        const trClass = isCurrent ? ' class="current-week-row"' : "";
        const distance = (week.distanceKm !== "" && week.distanceKm != null)
          ? `${week.distanceKm} km`
          : "";
        const sessions = week.sessions || "";
        const avgEffort = week.avgEffort || "";

        const startObj = parseLocalDate(week.startDate);
        const isPastOrCurrent = today >= startObj;

        let dateCell;
        if (week.weekUrl && isPastOrCurrent) {
          dateCell = `<a href="${week.weekUrl}">${dr}</a>`;
        } else if (week.weekUrl) {
          dateCell = `<span class="disabled-link">${dr}</span>`;
        } else {
          dateCell = dr;
        }

        return `
          <tr${trClass} data-week-start="${week.startDate}" data-cycle-id="${cycle.id}">
            <td>${week.order}</td>
            <td>${dateCell}</td>
            <td>${distance}</td>
            <td>${sessions}</td>
            <td>${avgEffort}</td>
          </tr>
        `;
      }).join("");

      return `
        <table class="nested-weeks-table">
          <thead>
            <tr>
              <th>周次</th>
              <th>日期范围</th>
              <th>距离</th>
              <th>训练次数</th>
              <th>平均主观强度</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
      `;
    }

    function populateWeeksTable(detailRow, cycle) {
      const weeks = buildCycleWeeks(cycle);
      const tbody = detailRow.querySelector(".nested-weeks-table tbody");
      if (!tbody) return;

      weeks.forEach(week => {
        const row = tbody.querySelector(`tr[data-week-start="${week.startDate}"]`);
        if (!row) return;

        const cells = row.querySelectorAll("td");
        if (cells.length < 5) return;

        const distanceCell = cells[2];
        const sessionsCell = cells[3];
        const effortCell = cells[4];

        const jsonPath = `../data/week-${week.startDate}.zh.json`;

        fetch(jsonPath)
          .then(resp => {
            if (!resp.ok) {
              throw new Error("No data");
            }
            return resp.json();
          })
          .then(data => {
            if (typeof data.total_distance_km === "number") {
              distanceCell.textContent = data.total_distance_km.toFixed(2) + " 公里";
            }
            if (typeof data.activity_count === "number") {
              sessionsCell.textContent = data.activity_count;
            }
            if (typeof data.avg_suffer_score === "number") {
              effortCell.textContent = data.avg_suffer_score.toFixed(1);
            }
          })
          .catch(() => {
            // No JSON for this week: leave cells empty
          });
      });
    }

    function renderCyclesTable(currentCycleIndex, currentWeekOrderByCycleId) {
      const tbody = document.querySelector("#cycles-table tbody");
      tbody.innerHTML = "";

      cyclesData.forEach((cycle, idx) => {
        const tr = document.createElement("tr");
        tr.classList.add("cycle-row");
        if (idx === currentCycleIndex) {
          tr.classList.add("current-cycle-row");
        }
        tr.dataset.cycleId = cycle.id;

        tr.innerHTML = `
          <td>
            <a href="${cycle.cyclePage}" class="cycle-link">${cycle.name}</a>
          </td>
          <td>${formatDateRange(cycle.startDate, cycle.endDate)}</td>
          <td>${cycle.lengthWeeks}</td>
          <td>${cycle.finalEvent}</td>
          <td>${cycle.target}</td>
        `;

        tbody.appendChild(tr);
      });

      // 展开/折叠逻辑 + 在展开的二级表格中高亮当前周
      tbody.addEventListener("click", (event) => {
        const row = event.target.closest("tr.cycle-row");
        if (!row) return;

        const cycleId = row.dataset.cycleId;
        const existingDetailRow = row.nextElementSibling;
        const isOpen = existingDetailRow && existingDetailRow.classList.contains("cycle-weeks-row");

        // 如果已经展开则折叠
        if (isOpen) {
          existingDetailRow.remove();
          row.classList.remove("expanded");
          return;
        }

        // 关闭其他已展开的行
        const allDetailRows = tbody.querySelectorAll(".cycle-weeks-row");
        allDetailRows.forEach(r => r.previousElementSibling?.classList.remove("expanded"));
        allDetailRows.forEach(r => r.remove());

        const cycle = cyclesData.find(c => String(c.id) === String(cycleId));
        const detailRow = document.createElement("tr");
        detailRow.classList.add("cycle-weeks-row");

        const currentWeekOrder = currentWeekOrderByCycleId[cycle.id] ?? null;

        detailRow.innerHTML = `
          <td colspan="5">
            <div class="cycle-weeks-wrapper">
              <h3>Weeks in ${cycle.name}</h3>
              ${createWeeksTable(cycle, currentWeekOrder)}
            </div>
          </td>
        `;

        row.insertAdjacentElement("afterend", detailRow);
        row.classList.add("expanded");

        // After the nested table is rendered, populate distance/sessions/effort
        populateWeeksTable(detailRow, cycle);
      });
    }

    function updateCurrentWeekCard(currentCycleIndex, currentWeekOrderByCycleId) {
      const card = document.getElementById("current-week-section");
      const meta = document.getElementById("current-week-meta");
      const dates = document.getElementById("current-week-dates");
      const focus = document.getElementById("current-week-focus");
      const link = document.getElementById("current-week-link");

      if (currentCycleIndex < 0 || currentCycleIndex >= cyclesData.length) {
        card.style.display = "none";
        return;
      }

      const cycle = cyclesData[currentCycleIndex];
      const cycleRangeLabel = formatDateRange(cycle.startDate, cycle.endDate);
      const currentWeekOrder = currentWeekOrderByCycleId[cycle.id] ?? null;
      const weeks = buildCycleWeeks(cycle);
      let currentWeek = null;

      if (currentWeekOrder != null) {
        currentWeek = weeks.find(w => w.order === currentWeekOrder) || null;
      }

      if (currentWeek) {
        const weekRange = formatDateRange(currentWeek.startDate, currentWeek.endDate);
        meta.textContent = `${cycle.name} · 第 ${currentWeek.order} 周`;
        dates.textContent = `日期：${weekRange}`;
        focus.textContent = cycle.target ? `目标：${cycle.target}` : "";

        if (currentWeek.weekUrl) {
          link.innerHTML = `周记：<a href="${currentWeek.weekUrl}">${currentWeek.weekUrl}</a>`;
        } else {
          link.innerHTML = "";
        }
      } else {
        // 没有当前周（比如未来还没细化周计划），就用整个 Cycle 信息填卡片
        meta.textContent = cycle.name;
        dates.textContent = `周期范围：${cycleRangeLabel}`;
        focus.textContent = cycle.target ? `目标：${cycle.target}` : "";
        if (cycle.cyclePage) {
          link.innerHTML = `周期页面：<a href="${cycle.cyclePage}">${cycle.cyclePage}</a>`;
        } else {
          link.innerHTML = "";
        }
      }

      card.style.display = "block";
    }

    function renderSeasonTimeline(currentCycleIndex, currentWeekOrderByCycleId) {
      const bar = document.getElementById("season-timeline-bar");
      const arrow = document.getElementById("season-timeline-arrow");
      const labels = document.getElementById("season-timeline-labels");
      if (!bar || !arrow) return;

      bar.innerHTML = "";
      if (labels) {
        labels.innerHTML = "";
      }

      // Collect cycles with their weeks
      const cycleBlocks = [];
      let totalWeeks = 0;
      cyclesData.forEach((cycle, idx) => {
        const weeks = buildCycleWeeks(cycle);
        cycleBlocks.push({ cycle, idx, weeks });
        totalWeeks += weeks.length;
      });

      // Build visual blocks
      cycleBlocks.forEach(({ cycle, idx, weeks }) => {
        const cycleDiv = document.createElement("div");
        cycleDiv.className = "season-cycle-block";
        cycleDiv.style.flex = String(weeks.length);

        // Alternate background colors per cycle
        const isEven = idx % 2 === 0;
        cycleDiv.style.background = isEven ? "var(--berlin-blue-light, #e5f0ff)" : "var(--berlin-blue, #0057aa)";

        weeks.forEach((week) => {
          const tick = document.createElement("div");
          tick.className = "season-week-tick";

          const currentWeekOrder = currentWeekOrderByCycleId[cycle.id];
          if (currentWeekOrder != null && week.order === currentWeekOrder && idx === currentCycleIndex) {
            tick.classList.add("season-week-current");
          }

          cycleDiv.appendChild(tick);
        });

        bar.appendChild(cycleDiv);

        if (labels) {
          const labelDiv = document.createElement("div");
          labelDiv.className = "season-cycle-label";
          labelDiv.style.flex = String(weeks.length);
          let labelText;
          if (idx === cyclesData.length - 1) {
            labelText = "终期";
          } else {
            labelText = "训练周期 " + (idx + 1);
          }
          labelDiv.textContent = labelText;
          labels.appendChild(labelDiv);
        }
      });

      // Compute arrow position (current week index among all weeks)
      let currentIndex = null;
      let running = 0;
      cycleBlocks.forEach(({ cycle, weeks }) => {
        const currentWeekOrder = currentWeekOrderByCycleId[cycle.id];
        if (currentWeekOrder != null && currentIndex === null && cyclesData[currentCycleIndex].id === cycle.id) {
          currentIndex = running + (currentWeekOrder - 1);
        }
        running += weeks.length;
      });

      if (currentIndex == null || totalWeeks === 0) {
        arrow.style.display = "none";
      } else {
        const positionPercent = ((currentIndex + 0.5) / totalWeeks) * 100;
        arrow.style.left = positionPercent + "%";
        arrow.style.display = "block";
      }
    }

    (function init() {
      const currentCycleIndex = getCurrentCycleIndex();
      const currentWeekOrderByCycleId = {};

      cyclesData.forEach(cycle => {
        currentWeekOrderByCycleId[cycle.id] = getCurrentWeekOrderInCycle(cycle);
      });

      renderCyclesTable(currentCycleIndex, currentWeekOrderByCycleId);
      updateCurrentWeekCard(currentCycleIndex, currentWeekOrderByCycleId);
      renderSeasonTimeline(currentCycleIndex, currentWeekOrderByCycleId);
    })();

    function buildSeasonChart() {
      const canvas = document.getElementById("season-weeks-chart");
      if (!canvas) return;

      const allWeeks = [];
      const cycleBoundaries = [];
      let runningIndex = 0;

      cyclesData.forEach(cycle => {
        const weeks = buildCycleWeeks(cycle);
        weeks.forEach(w => {
          allWeeks.push({ ...w, cycleId: cycle.id });
        });
        runningIndex += weeks.length;
        cycleBoundaries.push(runningIndex);
      });

      const labels = [];
      const distances = [];
      const sessions = [];
      const efforts = [];
      let remaining = allWeeks.length;

      if (remaining === 0) {
        return;
      }

      allWeeks.forEach(w => {
        const jsonPath = `../data/week-${w.startDate}.zh.json`;

        fetch(jsonPath)
          .then(resp => (resp.ok ? resp.json() : null))
          .then(data => {
            // label by week number within cycle, like nested table first column
            labels.push(String(w.order ?? ""));
            distances.push(data?.total_distance_km ?? null);
            sessions.push(data?.activity_count ?? null);
            efforts.push(data?.avg_suffer_score ?? null);
          })
          .catch(() => {
            distances.push(null);
            sessions.push(null);
            efforts.push(null);
          })
          .finally(() => {
            remaining--;
            if (remaining === 0) {
              drawSeasonChart(canvas, labels, distances, sessions, efforts, cycleBoundaries);
            }
          });
      });
    }

function drawSeasonChart(canvas, labels, distances, sessions, efforts, cycleBoundaries) {
  const ctx = canvas.getContext("2d");
  const width = canvas.width;
  const height = canvas.height;

  ctx.clearRect(0, 0, width, height);

  const paddingLeft = 40;
  const paddingRight = 20;
  const paddingTop = 20;
  const paddingBottom = 40;

  const chartWidth = width - paddingLeft - paddingRight;
  const chartHeight = height - paddingTop - paddingBottom;

  const values = [...distances, ...sessions, ...efforts].filter(v => typeof v === "number");
  const globalMax = values.length ? Math.max(...values) * 1.1 : 1;

  function valueToY(v) {
    if (v === null || Number.isNaN(v)) return null;
    const ratio = v / globalMax;
    return paddingTop + (1 - ratio) * chartHeight;
  }

  const stepX = labels.length > 1 ? chartWidth / (labels.length - 1) : 0;

  // axes
  ctx.strokeStyle = "#ccc";
  ctx.beginPath();
  ctx.moveTo(paddingLeft, paddingTop);
  ctx.lineTo(paddingLeft, paddingTop + chartHeight);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(paddingLeft, paddingTop + chartHeight);
  ctx.lineTo(paddingLeft + chartWidth, paddingTop + chartHeight);
  ctx.stroke();

  // vertical dashed lines to separate cycles
  if (Array.isArray(cycleBoundaries) && cycleBoundaries.length > 1 && stepX > 0) {
    ctx.save();
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = "#0057aa";
    ctx.lineWidth = 1;
    for (let i = 0; i < cycleBoundaries.length - 1; i++) {
      const idxBoundary = cycleBoundaries[i];
      if (idxBoundary <= 0 || idxBoundary >= labels.length) continue;
      const x = paddingLeft + stepX * idxBoundary - stepX / 2;
      ctx.beginPath();
      ctx.moveTo(x, paddingTop);
      ctx.lineTo(x, paddingTop + chartHeight);
      ctx.stroke();
    }
    ctx.restore();
  }

  // y-grid
  ctx.fillStyle = "#666";
  ctx.font = "11px system-ui";
  for (let i = 0; i <= 4; i++) {
    const ratio = i / 4;
    const y = paddingTop + (1 - ratio) * chartHeight;
    const val = (globalMax * ratio).toFixed(0);

    ctx.fillText(val, 4, y + 3);

    ctx.strokeStyle = i === 0 ? "#ccc" : "#eee";
    ctx.beginPath();
    ctx.moveTo(paddingLeft, y);
    ctx.lineTo(paddingLeft + chartWidth, y);
    ctx.stroke();
  }

  // x-axis ticks and labels: week # within cycle (1, 2, 3, ...)  
  ctx.fillStyle = "#333";
  labels.forEach((lab, idx) => {
    const x = paddingLeft + stepX * idx;
    const yBase = paddingTop + chartHeight;

    // small tick
    ctx.strokeStyle = "#aaa";
    ctx.beginPath();
    ctx.moveTo(x, yBase);
    ctx.lineTo(x, yBase + 4);
    ctx.stroke();

    // label (e.g. W1, W2...)
    ctx.fillText(lab, x - 10, yBase + 18);
  });

    // cycle labels centered under the x-axis (训练周期 1..训练周期 5, 终期)
  if (Array.isArray(cycleBoundaries) && cycleBoundaries.length > 0 && stepX > 0) {
    ctx.fillStyle = "#555";
    ctx.font = "11px system-ui";
    const yCycleLabel = paddingTop + chartHeight + 32;

    for (let i = 0; i < cycleBoundaries.length; i++) {
      const startIndex = i === 0 ? 0 : cycleBoundaries[i - 1];
      const endExclusive = cycleBoundaries[i];
      if (endExclusive <= startIndex) continue;

      // 当前 cycle 在线上的中心索引
      const centerIndex = (startIndex + endExclusive - 1) / 2;
      const x = paddingLeft + stepX * centerIndex;

      let labelText;
      if (i === cycleBoundaries.length - 1) {
        labelText = "终期";
      } else {
        labelText = "训练周期 " + (i + 1);
      }

      ctx.fillText(labelText, x - 12, yCycleLabel);
    }
  }

  function drawLine(values, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;

    values.forEach((v, idx) => {
      const y = valueToY(v);
      if (y === null) return;

      const x = paddingLeft + stepX * idx;
      if (!started) {
        ctx.moveTo(x, y);
        started = true;
      } else {
        ctx.lineTo(x, y);
      }
    });

    ctx.stroke();
  }

  drawLine(distances, "#1f77b4");
  drawLine(efforts, "#d62728");
  drawLine(sessions, "#2ca02c");
}

document.addEventListener("DOMContentLoaded", buildSeasonChart);
  </script>
</body>
</html>